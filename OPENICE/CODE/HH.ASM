 	.MLIB	"HHMACS.LIB"
	.FILE	"HH.ASM"
	.WIDTH	132
	.OPTION	B,D,L,T
	.MNOLIST

*
*GET THE SYSTEM STUFF
*
	.INCLUDE	"HH.INC"
	.INCLUDE	"HHSTRING.H"
	.INCLUDE	"IMGTBL.GLO"
	.include	"hh.e"
	.include	"hhram.g"
	.include	"hhd.g"
	.include	"hhcmos.g"
	.include	"hhproc.g"
	.include	"hhmenu.g"
	.include	"hhutil.g"
	.include	"hhcoin.g"
	.include	"hhdutl.g"
	.include	"hhsnd.g"
	.include	"hhdtst.g"
	.include	"hhpall.g"
	.include	"hhmisc.g"
	.include	"hhc.g"
	.include	"hha.g"
	.include	"hhattrct.g"
	.include	"hhcx.g"
	.include	"hhpic.g"
	.include	"hhgame.g"

; end of include files
	.if XUNIT=1
	.ref	code_start, code_end, code_dest
	.ref	vector_start, vector_end, vector_dest
	.endif

	.IF DEBUG
	.ref	CPUCHK1,CPUCHK2,CPUCHK3,CPUCHK4,CPUCHK5
	.ref	CLIPTIM,SCALETIM,VELTIM,PROCTIM

	.REF	WAVEDMABOG, WAVECPUBOG, NOVELADD

	.ENDIF

	.BSS	EXECLED,16
	.BSS	IRQLED,16
	.BSS	DIPSW,16	;RAM FAKE FOR NON-EXISTANT DIP SWITCHES
	.BSS	SWITCH_ESCAPE,16 ;SWITCH ESCAPE FLAG USED BY SLEEP_SWITCHX
	.BSS	SWITCH_SPOKEN,16 ;SWITCH SPEAK FLAG
	.BSS	DMASKIPBOG,16	;Flag to skip BOG calculator for one frame

	.TEXT

	.STRING "OOPPEENN  IICCEE  "
	.STRING "CCOOPPYYRRIIGGHHTT  ((cc))  "
	.STRING	"11999955  MMIIDDWWAAYY  "
	.STRING "MMAANNUUFFAACCTTUURRIINNGG  "
	.STRING	"CCOOMMPPAANNYY..  "
	.EVEN

**************************************************************************
*								         *
* 	POWERUP								 *
* 									 *
* 	This section of code is Loaded and Executed from the Image	 *
* 	ROM area.  Not only will it handle power-on diagnostics,	 *
* 	but it will also copy the program into RAM space.		 *
* 									 *
* 	The 020 will have to be initialized properly and once		 *
* 	the copying is done, the DMA must get priority over the		 *
* 	image ROM.							 *
*								         *
**************************************************************************
POWERUP
	DINT
	SETF	16,1,0			;WORD SIGN EXTEND
	SETF	32,1,1			;LONG WORD

        MOVI	STCKST,SP,L

;MJL Start
	movi	VMUX_INIT,a0
	move	a0,@VMUX_CONTROL,W
;MJL End
	movi	SYSCINIT,a0
	move	a0,@SYSCTRL,W

	CALLR	INIT_DMACONFIG		;INITIALIZE DMACONFIG REGISTER
*INIT COLOR RAM
	CLR	A0
	MOVE	A0,@DMAGOREG,L		; XUNIT
	MOVE	A0,@DMAGOREG,L	  	; XUNIT  OFF DMA
	MOVE	A0,@CMAPSEL		;CLEAR COLOR MAP SELECT

	CALLA	SCRCLR

*
* Manual sound board reset.  Yes, you will get the dongs. OH, NO YOU WON'T!
*

	movi	SNDRSTBIT|IORSTBIT,a0
	move	a0,@COIN_COUNTERS,W
	MSECWT	110		;Wait for sound board to catch it
	movi	IORSTBIT,a0
	move	a0,@COIN_COUNTERS,W

;MJL Start
	move	@SOUNDIRQ,a0		; read watchdog status
	btst	8,a0			; Is this reset from a watchdog ?
	jrnz	initp50			; br = no
	AUDIT	AUD_DOG			;CLICK A WATCH DOG RESET
	MOVK	2,A14
	getpc	B14			;Show where we are
	CALLA	DUMP_IT

initp50
	move	a0,@WDOG_BONE		; Kill the dog fer yucks
	calla	InitPIC			; Initialize the PIC and the I/O system
	move	a0,@WDOG_BONE		; Kill the dog fer yucks
	jauc	POWERTST		; Go off and run the power up tests
POWERRET
;	move	a0,@WDOG_BONE		; Kill the dog fer yucks
;	calla	InitPIC			; Reinitialize the PIC and I/O system
;
;	movi	SYSCINIT,a0
;	move	a0,@SYSCTRL,W
;
;	move	a0,@WDOG_BONE		; Kill the dog fer yucks


*
*NOW THAT THE POWER ON TESTS ARE DONE, WE CAN INITIALIZE AGAIN, FOR REAL!
SETUP
WARMSET
	DINT
	SETF	16,1,0	;WORD SIGN EXTEND
	SETF	32,1,1	;LONG WORD

;	move	@SYSCTRL,a0,W
;	ori	ROMWRINTDIS|CLR_WRROMINT,a0
;	move	a0,@SYSCTRL,W

	.if	XUNIT=0
	movi	VMUX_INIT,a0
	move	a0,@VMUX_CONTROL,W
	.endif

	MOVI	STCKST,SP,L
	CALLR	CLSCRACH		;CLEAR SCRATCHPAD
	MOVI	SYSCINIT,A0		;

	.if	XUNIT=1
	MOVE	A0,@SYSCOPY		; GET EVERYBODY HAPPY
	MOVE	A0,@SYSCTRL0,L		; XUNIT
	srl	8,a0			; XUNIT
	move	a0,@SYSCTRL1,L		; XUNIT
	.else
	move	a0,@SYSCTRL,W
	.endif

;	CALLA	LAMPS_OFF		;TURN LAMPS OFF

	CALLR	DIPINIT
;MJL Start
	calla	InitPIC
;MJL End
	JAUC	POWERCMOS		;VERIFY CMOS AND PRINT OPENING MESSAGE
PCMOSRET
	CALLR	MAIN_INIT	;DO NORMAL INITIALIZATIONS
;MJL Start
; These are stored in these reggies to protect them from mem clear
	move	b5,@_serial_number,L
	move	b6,@_man_date,L
;MJL End
	CALLA	TIMEINIT	;WHY MUST WE DO THIS?

	EINT			;ENABLE INTERRUPTS AND WE'RE OFF
	DISPON			;ENABLE THE DISPLAY SYSTEM

	CALLA	CKDIAG		;ARE ANY OF THE DIAG SWITCHES CLOSED?
	JRZ	MAIN_GO		;BR = NO
	CREATE	PID_DIAG,DIAG	;FIRE OFF THE DIAG PROCESS
	JRUC	EXEC_LP		;AND THEN DISPATCH IT.
MAIN_GO
	CLR	A0
	MOVE	A0,@COINFLAG,W	; NOT ON COIN PAGE YET
	calla	cx_powerup
	CALLA	ATSTRT		;START ATTRACT MODE

**************************************************************************
*								         *
* 		START OF EXECUTIVE LOOP					 *
*								         *
**************************************************************************
EXEC_LP
	CALLA	PRCDSP		;DISPATCH PROCESSES
	MOVE	A13,A13		;DID PROCESS EXECUTE CORRECTLY?
	JRZ	EXEC_POK	;BR = YES
	LOCKUP			;REPORT THE SITUATION
EXEC_POK
*
*UNSTACK THE VALID SWITCH CLOSURES AND ACTIVATE PROCESSES
*
	MOVI	ACTIVE,A13,L
	MOVE	@SWSTACK,A3,L
EXEC_UNSTKLP
	CMPI	SWSTST,A3,L	;STACK AT START?
	JREQ	EXEC_UNSTKX	;YES, EXIT
	MOVE	@FREE,A0,L
	JRZ	EXEC_UNSTKX	;NO PROCESSES LEFT, TRY NEXT TIME AROUND
	MOVE	*A3+,A0,W	;GET ENTRY
	MOVE	A3,@SWSTACK,L	;UPDATE STACK
	MOVE	A0,A2
	ADD	A0,A2
	ADD	A0,A2		;MULT BY 3
	SLL	4,A2		;ADJUST FOR WORD SIZE (16)
	ADDI	SWTAB,A2
	MOVE	*A2+,A1		;GET PID
	MOVE	*A2+,A7,L	;GET STARTING ADDR
	JREQ	EXEC_UNSTKLP	;NULL ENTRY
EXEC_SWITCH_CREATE
	CALLA	GETPRC
	JRUC	EXEC_UNSTKLP
EXEC_UNSTKX
	CALLA	RANDOM		;RESEED THE RANDOM NUMBER GENERATOR

	calla	sound_exec

	MOVE	@EXECLED,A0,W
	INC	A0
	MOVE	A0,@EXECLED,W
	CMPI	5,A0
	JRLT	EXEC_LP		;BR = NOT TIME TO BLINK THE EXEC LED

	CLR	A0
	MOVE	A0,@EXECLED,W

	PUSHST
	DINT
*
*DO SOME SYSCTRL STUFF WHILE INTERRUPTS ARE OFF
*

	.if	XUNIT=1
	MOVE	@SYSCOPY,A0	;BLINK L.E.D. TO ACK OPERATION
	XORI	LED_ON<<8,A0 	; XUNIT
	MOVE	A0,@SYSCOPY	; XUNIT
	srl	8,a0		; XUNIT
	MOVE	A0,@SYSCTRL1,L	; XUNIT
	.else
	MOVE	@SYSCTRL,A0,W
	xori	LED_ON,a0
;	move	a0,@SYSCOPY
	move	a0,@SYSCTRL,W
	.endif

	POPST

	CALLR	StCpuLft
	JRUC	EXEC_LP


**************************************************************************
*								         *
* 			END OF EXECUTIVE LOOP				 *
*								         *
**************************************************************************

**************************************************************************
*								         *
* StCpuLft - ROUTINE TO CALCULATE CPU TIME LEFT				 *
*								         *
**************************************************************************
StCpuLft
	move	@TIMER,A0,W
	jrz	NoBog
	movi	EOSINT,a1
	clr	A1
	jruc	GotTime
NoBog	movi	EOSINT,A1
	move	@VCOUNT,A0
;MJL
	jrn	StCpuLft_aBoRt
;MJL END
	sub	A0,A1
	JRN	StCpuLft_aBoRt	;BR = Something is strange with the value

	.if	bog_line
	move	a0,@bog_cpu
	.endif

	movi	1000*10000H/EOSINT,A0
	mpyu	A0,A1
	srl	16,A1
GotTime	move	A1,@CPULEFT,W
	MOVE	@CPULOW,A0,W
	CMP	A0,A1
	JRGE	NO_NEWLOW
	MOVE	A1,@CPULOW,W
NO_NEWLOW
	MOVE	@CPUHI,A0,W
	CMP	A0,A1
	JRLE	NO_NEWHI
	MOVE	A1,@CPUHI,W
NO_NEWHI
	srl	3,A1
	move	@CPUAVG,A0,W
	move	A0,A2
	srl	3,A2
	sub	A2,A0
	add	A0,A1
	move	A1,@CPUAVG,W
StCpuLft_aBoRt
	rets


**************************************************************************
*								         *
* MAIN_INIT - CUMBERSOME SYSTEM INITIALIZATION STUFF, USED TO BRING	 *
* 		UP THE SYSTEM COLD.					 *
* 	    RAM MUST BE O.K., STACK POINTER VALID AND FIELDS SET.	 *
* RETURNS								 *
* 	A13 = PROCESS ACTIVE LIST					 *
*								         *
**************************************************************************
MAIN_INIT
	PUSH	A0

	MOVI	INAMODE,A0
	MOVE	A0,@GAME_STATE,W
	MOVI	0FFFFH,A0
	MOVE	A0,@SOUND_COPY,W	;INITIALIZE THE SOUND PORT COPY
	CALLR	INITIO			;INITIALIZE THE I/O REGS
	CALLR	INIT_DMACONFIG		;INITIALIZE DMACONFIG REGISTER
*SET UP TI PIXEL PROCESSING REGS
	CALLA	SETPPROC
*INIT COLOR RAM
	CLR	A0
	MOVE	A0,@DMAGOREG,L		; XUNIT
	MOVE	A0,@DMAGOREG,L	  	; XUNIT  OFF DMA
	MOVE	A0,@CMAPSEL		;CLEAR COLOR MAP SELECT
	MOVE	A0,@IRQLED
	MOVE	A0,@EXECLED
*CLEAR THE SCREEN
	CALLA	SCRCLR

*INITIALIZE RANDOM SEED
	MOVI	81261A8CH,A0
	MOVE	A0,@RAND,L
*ENABLE DISPLAY INTERRUPT
	.if	WRITE_TO_ROM_INT
	MOVI  	DIE|X2E,A0
	.else
	MOVI  	DIE,A0
	.endif
	MOVE  	A0,@INTENB		;enable display interrupts

	.if	XUNIT=1
*Initialize the System interrupt register
	MOVIM	LINT2_INTS,@INT_REG,L
	.endif

*INITIALIZE SWITCH STACK
	MOVI	SWSTST,A0
	MOVE	A0,@SWSTACK,L
*INITIALIZE SYSTEM CONTROL REGISTER
	MOVI	SYSCINIT,A0

	.if	XUNIT=1
	MOVE	A0,@SYSCOPY		;KEEP A COPY IN RAM
	MOVE	A0,@SYSCTRL0,L		; XUNIT
	srl	8,a0			; XUNIT
	MOVE	A0,@SYSCTRL1,L		; XUNIT
	.else
	move	a0,@SYSCTRL,W
	.endif

*INITIALIZE DIP SWITCH OPTIONS
	CALLR	DIPINIT
*INITIALIZE PROCESS AND DISPLAY LISTS AND START THE SYSTEM
	CALLA	PINIT 		;INIT PROCESS LIST
	CALLA	OINIT		;DO THIS FIRST FOR THE DMA'S SAKE
	CALLA	MYOINIT		;INITIALIZE THE OBJECT LIST
	CALLA	CLEAR_PAGE2	;Clear video bit map page 2
	CALLA	CLEAR_PAGE3	;Clear video bit map page 3
*RESET THE SOUND BOARD - Must be called after the process system is init'd

	.if	DEBUG
	CALLA	QSNDRST
	.else
	CALLA	SNDRES
	.endif

	PULL	A0
	RETS

**************************************************************************
*								         *
* INIT_DMACONFIG - INITIALIZE THE DMACONFIG				 *
*								         *
* CALL DIS UPON POWER UP						 *
*								         *
**************************************************************************
INIT_DMACONFIG
	MOVIM	DMACF4,@DMACONFIG,L	;ADJUST WINDOW RIGHT/LEFT BORDER
	movi	[511,0],a14
	move	a14,@DMAWINDOW,L
	MOVI	DMAWIN|DMACF4,A14
	MOVE	A14,@DMACFIGCOPY,L
	MOVE	A14,@DMACONFIG,L 	;LEAVE CONFIG'D FOR TOP/BOT ADJUSTMENT
	RETS

**************************************************************************
*                                                                        *
* DIPINIT - INITIALIZE OPTIONS VIA DIP SWITCH SETTINGS			 *
*                                                                        *
**************************************************************************
DIPINIT
	MMTM	SP,A0,A1
	CALLA	READ_DIP		;LOAD UP THE CURRENT DIP SWITCH BITS
	MOVE	A0,A1	   		;STORE FOR MULTIPLE USES
	ANDI	DPPLAYERS,A0		;AQUIRE THE NUMBER OF PLAYERS
	SRL	SR_DPPLAYERS-3,A0       ; WBD
	ADDI	PLNUM,A0
	MOVB	*A0,A0
	MOVE	A0,@NPLAYERS,W
	MMFM	SP,A0,A1
	RETS

PLNUM	.BYTE	4,2                     ; WBD
	.EVEN

**************************************************************************
*                                                                        *
* ATSTRT - START THE ATTRACT MODE PROCESS				 *
*                                                                        *
**************************************************************************
ATSTRT_CREDITS_NOCPJ
	MMTM	SP,A0,A1,A7
	movk	3,a0
	jruc	atgo1
ATSTRT_CREDITS
	MMTM	SP,A0,A1,A7
	movk	2,a0
	move	@COINFLAG,a14,W
	jrnz	atgocln		;we are on credit page, do a clean go with no wipeout
	jruc	atgo1
ATSTRT_TOPTEN
	MMTM	SP,A0,A1,A7
	movk	1,a0
	jruc	atgo1
ATSTRT
	MMTM	SP,A0,A1,A7
	clr	a0
atgo1	mmtm	sp,a0
	MOVE	@in_at_game,A14,W
	jrz	noqu
	calla	kill_all_sound

	mmfm	sp,a0
	cmpi	2,a0
	mmtm	sp,a0
	jrnz	atgor
	move	@SOUNDSUP,a0,W
	clr	a14
	move	a14,@SOUNDSUP,W
	movi	S_CREDIT,a4
	calla	do_sound
	move	a0,@SOUNDSUP,W
atgor
noqu	calla	MY_WIPEOUT
	jruc	atgoc
atgocln	mmtm	sp,a0
	move	@COINFLAG,a1,W
	mmtm	sp,a1
	calla	my_wipeout_novideo_noprocess	;we should kill everything but indes, and the credit flash
	mmfm	sp,a1
	move	a1,@COINFLAG,W
atgoc	mmfm	sp,a0
	move	a0,@amode_starting_point
	CLR	A1
	MOVE	A1,@WAVEIRQS,L		;RESET FOR TIMING IN ATTRACT MODE
	cmpi	3,a0
	jrz	nocpj
	MOVK	3,A1
	MOVE	A1,@CREDIT_PAGE_JUMPS,W	;NUMBER OF JUMPS LEFT TO CREDIT PAGE
nocpj	MOVI	INAMODE,A1
	MOVE	A1,@GAME_STATE,W
	MOVKM	1,@GAMERASE,W		;AUTO-ERASE FULL
	C_A_K	PID_ATTRACT_MODE,ATTRACT_MODE
	MMFM	SP,A0,A1,A7
DUMRETS
DUMCOL
	RETS

**************************************************************************
*								         *
* WIPEOUT - WIPES THE SYSTEM CLEAR OF ALL OTHER PROCESSES, OBJECTS	 *
* 	  AND COORDINATES.						 *
* 	  IT RETURNS WITH THE DISPLAY SYSTEM AND AUTO-ERASE SHUT OFF,	 *
* 	  COLOR RAM CLEARED, AND THE BIT MAP WIPED CLEAN.		 *
* 	  THIS IS NICE TO USE WHEN SWITCHING BETWEEN STUFF.		 *
* NOTE: TRASHES A14							 *
*								         *
**************************************************************************
WIPEOUT
	MMTM	SP,A0,A1,A7

;	CALLA	LAMPS_OFF

        CLR     A0
	MOVE	A0,@PAGE,W
	MOVE	A0,@COINFLAG,W		;NOT ON COIN PAGE YET
	MOVE	A0,@NOPGFLIP,W		;ALLOW PAGE FLIPPING
	MOVE	A0,@SWITCH_SPOKEN,W	;SWITCH SPEAK FLAG
	CALLR	KILL_DESTRUCTIBLES
	CLR	A0
	MOVE	A0,@GAMERASE,W
	MOVE	A0,@DISPLAYON,W		;TURN THE DISPLAY PROCESSOR OFF
	MOVE	A0,@in_at_game,W
	move	a0,@octopus_count,W
	CALLA	CLRDMAQ			;RESET THE Q
	CALLA	DMAWAIT			;WAIT ON DMA TO FINISH
	PUSHST
	DINT
	CALLA	CLRSWPRC
	CALLA	MYOINIT			;RE-INIT THE OBJECT LIST
	CALLR	SYSINITL
	CALLA	CLR_SCRN		;WIPE OUT THE BIT MAP

	MOVE	@INTPEND,A1,W		;CLEAR INTERRUPT PENDING
	ANDNI	DIE,A1
	MOVE	A1,@INTPEND,W
	POPST

;ALREADY DONE IN MYOINIT!
;	CALLA	IAUTOE			;INITIALIZE THE AUTO ERASE AREA

	CLR	A0
	MOVE	A0,@IRQSKYE,W		;CLR THE AUTO-ERASE COLOR
	MOVE	@SUPRESS_PAGE_FLIP,A14,W
	JRNZ	WO_NO_PF

	.if	XUNIT=1
	MOVI	DPYSTRT0,A0
	MOVE	A0,@DPYST,L		;XUNIT RESET DISPLAY START POINT
	.else
;	movi	0fffch,a0
	movi	0ch,a0
	move	a0,@DPYSTRT,W
	.endif

WO_NO_PF
	MMFM	SP,A0,A1,A7
	RETS

**************************************************************************
*								         *
* WIPEOUT_NOVIDEO							 *
* 									 *
* same as WIPEOUT, but don't touch the video screen			 *
*								         *
**************************************************************************
WIPEOUT_NOVIDEO_NOPROCESS
	MMTM	SP,A0,A1,A7
        CLR     A0
	MOVE	A0,@COINFLAG,W		;NOT ON COIN PAGE YET
	MOVE	A0,@SWITCH_SPOKEN,W	;SWITCH SPEAK FLAG
	move	a0,@octopus_count,W
	PUSHST
	DINT
	CALLA	CLRSWPRC
	CALLR	SYSINITL
	POPST
	MMFM	SP,A0,A1,A7
	RETS

WIPEOUT_NOVIDEO
	MMTM	SP,A0,A1,A7

;	CALLA	LAMPS_OFF

        CLR     A0
	MOVE	A0,@PAGE,W
	MOVE	A0,@COINFLAG,W		;NOT ON COIN PAGE YET
	MOVE	A0,@NOPGFLIP,W		;ALLOW PAGE FLIPPING
	MOVE	A0,@SWITCH_SPOKEN,W	;SWITCH SPEAK FLAG
	CALLR	KILL_DESTRUCTIBLES
	CLR	A0
	MOVE	A0,@GAMERASE,W
	MOVE	A0,@DISPLAYON,W		;TURN THE DISPLAY PROCESSOR OFF
	move	a0,@octopus_count,W
	CALLA	CLRDMAQ			;RESET THE Q
	CALLA	DMAWAIT			;WAIT ON DMA TO FINISH
	PUSHST
	DINT
	CALLA	CLRSWPRC
;	CALLA	MYOINIT			;RE-INIT THE OBJECT LIST
	CALLR	SYSINITL
	MOVE	@INTPEND,A1,W		;CLEAR INTERRUPT PENDING
	ANDNI	DIE,A1
	MOVE	A1,@INTPEND,W
	POPST
;	CALLA	CLR_SCRN		;WIPE OUT THE BIT MAP
;	CALLA	IAUTOE			;INITIALIZE THE AUTO ERASE AREA
;	CLR	A0
;	MOVE	A0,@IRQSKYE,W		;CLR THE AUTO-ERASE COLOR
;	MOVE	@SUPRESS_PAGE_FLIP,A14,W
;	JRNZ	WO_NO_PF
;
;	.if	XUNIT=1
;	MOVI	DPYSTRT0,A0
;	MOVE	A0,@DPYST,L		;XUNIT RESET DISPLAY START POINT
;	.else
;;	movi	0fffch,a0
;	movi	0ch,a0
;	move	a0,@DPYSTRT,W
;	.endif
;
	MMFM	SP,A0,A1,A7
	RETS

**************************************************************************
*								         *
* KILL_DESTRUCTIBLES - KILL ALL OF THE DESTRUCTIBLE PROCESSES CURRENTLY	 *
* 		     ACTIVE.						 *
*								         *
**************************************************************************
KILL_DESTRUCTIBLES
	MMTM	SP,A0,A1,A7
	CLR	A0
	MOVI	M_INDESTRUCT,A1
	CALLA	KILALL			;KILL ALL BUT THE INDESTRUCTIBLES
;	CALLA	COLOR_START		;RE-START THE COLOR PROCESSES
	MMFM	SP,A0,A1,A7
	RETS

FREEZE_SW .EQU	8
FREEZE_DIP .EQU 9
**************************************************************************
*								         *
* FREEZE_ABSOLUTE - PROCESS TO FREEZE THE GAME ACTION WHEN THE FREEZE BU *
* 	 GOES FROM OFF TO ON. GAME RESUMES WHEN THE BUTTON IS RELEASED.	 *
*								         *
**************************************************************************
FREEZE_ABSOLUTE
	jauc	SUCIDE

**************************************************************************
*                                                                        *
* CLRSWPRC - MAKE ALL SWITCH TRIGGERED PROCESSES DUMDIE ENTRIES		 *
* NOTE: CALL WHEN INTERRUPTS ARE TURNED OFF				 *
*                                                                        *
**************************************************************************
CLRSWPRC
	MMTM	SP,A0,A1,A3
	MOVI	63,A1		;USE SWTAB ENTRY 40 FOR DUMDIE PROC
	MOVE	@SWSTACK,A3,L
CLRSTKL	CMPI	SWSTST,A3,L	;STACK AT START?
	JREQ	CLRSTKX		;YES, EXIT
	MOVE	*A3+,A0,W
	CMPI	63,A0
	JRLS	CLRSTKL		;THIS ENTRY IS A REAL SWITCH
	MOVE	A1,*A3(-10H),W	;STORE THE DUMDIE CALL
	JRUC	CLRSTKL
CLRSTKX
	MMFM	SP,A0,A1,A3
	RETS

**************************************************************************
*								         *
* 	CLSCRACH							 *
* 									 *
* 	Clear all of scratch pad RAM.					 *
* 									 *
* 	NOTE: A0,A1,A2 and A3 are trashed.				 *
* 	      This is very destructive. Make sure you setup 		 *
* 		all relevant variables after calling this.		 *
*								         *
**************************************************************************
CLSCRACH
	PULL	A3
*CLEAR SCRATCHPAD RAM
	CLR	A0
	MOVI	SCRATCH,A1,L
	MOVI	(SCRATCH_END-SCRATCH)/32,A2,L  	;CLEAR LONGS
SCTLP	MOVE	A0,*A1+,L
	DSJS	A2,SCTLP
	JUMP	A3

**************************************************************************
*                                                                        *
* SYSTEM ROUTINES AND PROCESSES						 *
*                                                                        *
**************************************************************************
*GAME RAM INITIALIZATION
GRAMINIT
	MMTM	SP,A0,A1,A2
	MOVI	GRAMSTRT,A1
	MOVI	GRAMEND,A2
	JRUC	RAMINIT
RAMINIT	CLR	A0
RAMLOOP	MOVE	A0,*A1+,W	;16 BITS AT A TIME, NO EXTRANEOUS CLEARS
	CMP	A2,A1		;DONE?
	JRLO	RAMLOOP		;NO!
	MMFM	SP,A0,A1,A2
	RETS

**************************************************************************
*                                                                        *
* SYSINITL - INITIALIZE LOW BYTE OF SYSTEM CONTROL REGISTER		 *
*                                                                        *
**************************************************************************
SYSINITL
	PUSH	A0
	MOVI	SYSCINIT,A0

	.if	XUNIT=1
	MOVE	A0,@SYSCOPY		;RE-INITIALIZE SYSTEM CONTROL REG
	MOVE	A0,@SYSCTRL0,L		; XUNIT
	srl	8,a0			; XUNIT
	MOVE	A0,@SYSCTRL1,L		; XUNIT
	MOVI	700H,A0
	MOVE	A0,@SECCHIP,L		; WHAT TO DO BOUT THIS ???XUNIT???
	MOVE	A0,@SECCHIP,L
	.else
	move	a0,@SYSCTRL,W
	.endif

	PULL	A0
	RETS

**************************************************************************
*								         *
* IAUTOE - ROUTINE TO INITIALIZE THE TWO AUTO-ERASE LINES TO THEIR	 *
* 		DEFAULT COLOR.						 *
*								         *
**************************************************************************
IAUTOE
	PUSH	A0
	movi	ERASECOL,A0		;color 63, pal 0
	move	A0,@NewAECol
	dec	A0
	move	A0,@OldAECol
	PULLQ	A0
	rets

**************************************************************************
*								         *
* SRT_CLR - ROUTINE TO CLEAR SCREEN BEFORE NEXT PLOT			 *
* NOTE: TRASHES MANY A AND B FILE REGISTERS				 *
* 	DON'T EXPLICITLY USE B11 - B13 UNLESS DMA INTERRUPT IS OFF.	 *
*								         *
**************************************************************************
SRT_CLR
*	color to clear to stored in Lines 510 and 511
	MOVE	@SKIPDISP,A0,W
	JRNZ	SRT_CLRX

	MOVE	@NOAUTOE,A0,W
	JRNE	SRT_CLRX		;DON'T ERASE

	movi	255,B2			;GET AUTO ERASE LINE
	MOVE	@GAMERASE,B9,W		;GET THE CURRENT AUTO-ERASE SCHEME
	JREQ	SRT_CLRX		;BR = AUTO-ERASE IS OFF

	SLL	6,B9
	ADDI	GAMERASE_TAB,B9
	MOVE	*B9+,B8,L		;GET THE SIZE
	MOVE	*B9,B7,L		;GET THE SIZE

	callr	SRT_CORE
SRT_CLRX
	rets
*
*	B2 = VLINE where erase color is found
*	B8 = START VLINE
*	B7 = [num_lines : 1]
*
SRT_CORE
	sll	12,b8		;convert start line to linear
	move	@CONVDP,A12,W
	movk	012H,B9
	move	B9,@CONVDP		;Move to CONVDP io register

* Set SRT=1.  This converts pixel accesses to VRAM SR transfer cycles.

	MOVE	@DPYCTL,B10,W		;Copy display control reg.
	move	B10,A13			; save in A file
	ANDNI	SRE+ENV,B10	     	;Turn off screen refresh
	ORI	CST,B10		     	; XUNIT Enable SR transfers
	MOVI	(4096*MICRO_SECOND)/4,A0	;MAX WAIT FOR 400X256 DMA
SrtDmaWt
	MOVE	@DMAGOREG,A14,L		;DMA STILL BUSY?
	JRNN	SRT_DMA_READY		;BR = NO, READY
	DSJS	A0,SrtDmaWt

	CLR	A14
	MOVE	A14,@DMAGOREG,L
	MOVE	A14,@DMAGOREG,L		;DMA off for sure

	CALLA	CLRDMAQ

SRT_DMA_READY

*
*WARNING! KEEP INTERRUPTS OFF UNTIL AFTER THE FILL INSTRUCTION
*	ASYNCHRONOUS BREAKS MAY CAUSE DMA INTERRUPT TO OCCUR
*	DURING FILL INSTRUCTION TRASHING THE B REGISTERS THAT
*	DETERMINE FILL RESTART AFTER INTERRUPT.
*	WHEN DEBUGGING THIS CAUSES SPURIOUS ILLEGAL OPCODES AND TRASHING
*	OF CODE SPACE.
*
	PUSHST
	DINT
	MOVE	B10,@DPYCTL,0 		;Load new display control
	movi	SCRN_PTCH*2,B3	 	;Get Screen Pitch

* Load frame buffer for 1st line into VRAM shift registers.
	CLR	B4		     	;Origin at start of memory
	sll	13,b2 		; change line number into address

	.if	XUNIT=1
	MOVK	1,A14
	MOVE	A14,@SECCHIP,L	;Hack for Steve and his bogus VRAMs
	.endif

	PIXT	*B2,B2		;Load VRAM shift registers

* Transfer contents of VRAM shift registers to rest of frame buffer.
	move	@PAGEADDR,B4,L
	clr	B2
	movx	b2,b4		; clear out X
	SRL	4,B4		; convert from XY to linear
	ADD	B8,B4
	MMTM	SP,B11,B12,B13
	FILL	 XY				;200 SR-to-memory transfers
	MMFM	SP,B11,B12,B13
	POPST
*END OF INTERRUPT DISABLE

* Restore previous contents of registers.
	move	A12,@CONVDP,W
   	MOVE 	A13,@DPYCTL,W		;Copy display control reg.
	rets

**************************************************************************
*								         *
* 			TABLE OF SCREEN ERASE PARAMS			 *
* 	ENTRY:								 *
*       .LONG   OFFSET TO START ERASE CLEAR     			 *
* 	.LONG	LENGTH OF ERASE DOMAIN					 *
*								         *
**************************************************************************
ERA_ENT .macro	TOP,BOTTOM
	.LONG	:TOP:*1000h
	.LONG	[((:BOTTOM:)-(:TOP:)+1)>01H,1]
	.endm

GAMERASE_TAB
	ERA_ENT	SCRTOP,SCRBOT
	ERA_ENT	SCRTOP,SCRBOT

**************************************************************************

*CALLED AT VERTICAL BLANK WHEN IT IS KNOWN THAT THE DMA IS FINISHED.
* IT WILL SWAP THE PLOT AND VIEWED PAGES, REPLACES SwapPgA AND SwapPgB.
SWAP_PAGES
	MOVE	@SUPRESS_PAGE_FLIP,A0,W	;Totally blow off all page changing?
	JRNZ	SWAP_PageAX	  	;BR = Yes

	MOVE	@NOPGFLIP,A0,W
	JRZ	SWAP_ME

	.if	XUNIT=1
*NO PAGE FLIPPING, JUST STICK IT ON PAGE 0
	clr	A0		;PLOT ON PAGE 0 now
	movi	PAGE0ADR,A1
	movi	DPYSTRT0,A2	;DISPLAY PAGE 0 now
       	JRUC	SWAP_SetPgAd

SWAP_ME
	MOVE	@SKIPDISP,A0,W
	jrnz	SWAP_PageAX

	;**** PAGE 1 starts on the 256th line of the video ram
	movk	1,A0		;Assume Page 1
	movi	PAGE1ADR,A1
	movi	DPYSTRT0,A2	;DISPLAY PAGE 0

	move	@PAGE,A14,W
	jrz	SWAP_SetPgAd

	;**** PAGE 0 starts on the 0th line of the video ram
	clr	A0		;PLOT ON PAGE 0 now
	movi	PAGE0ADR,A1
	movi	DPYSTRT1,A2	;DISPLAY PAGE 1 now

SWAP_SetPgAd
	move	A1,@PAGEADDR,L
	move	A0,@PAGE,W
;XUNIT	move	a2,@DPYADR		;Override DPYSTRT
	move	a2,@DPYST,L 	; XUNIT Stuff our new DPYST to be cool
	MOVE	A2,@DPYNX,L	; XUNIT Override DPYST and take effect immeadiately

	.else

*NO PAGE FLIPPING, JUST STICK IT ON PAGE 0
	clr	A0		;PLOT ON PAGE 0 now
	movi	PAGE0ADR,a1
;	movi	0fffch,a2
	movi	0ch,a2
       	JRUC	SWAP_SetPgAd

SWAP_ME
	MOVE	@SKIPDISP,A0,W
	jrnz	SWAP_PageAX

	;**** PAGE 1 starts on the 256th line of the video ram
	movk	1,A0		;Assume Page 1
	movi	PAGE1ADR,a1
;	movi	0fffch,a2	;Display page 0
	movi	0ch,a2	;Display page 0

	move	@PAGE,A14,W
	jrz	SWAP_SetPgAd

	;**** PAGE 0 starts on the 0th line of the video ram
	clr	A0		;PLOT ON PAGE 0 now
	movi	PAGE0ADR,a1
;	movi	0f01ch,a2	;Display Page 1
	movi	0f02ch,a2	;Display Page 1

SWAP_SetPgAd
	move	A1,@PAGEADDR,L
	move	A0,@PAGE,W
	move	a2,@DPYADR,W		;Override DPYSTRT
	move	a2,@DPYSTRT,W

	.endif

SWAP_PageAX
	rets

**************************************************************************

ENABLE_DIRQ2	EQU	1	;ALLOW UPDATING OF AUTO-ERASE COLOR

**************************************************************************
*                                                                        *
* DIRQ - DISPLAY IRQ, USES THE VALUE STORED @DPYINT TO DETERMINE	 *
*        WHICH INTERRUPT WE HAVE RECEIVED.				 *
*                                                                        *
**************************************************************************
DIRQ
	.if	XUNIT=1
	MMTM	SP,A0,A1,A2,A3,A4,A5,A6,A7,A8,A9,A10,A11,A12,A13,A14
	MMTM	SP,B0,B1,B2,B3,B4,B5,B6,B7,B8,B9,B10,B14
	.else
	MMTM	SP,A0,A1,A2,A3,A4,A5,A6,A7,A8,A9,A10,A11,A12,A13,A14
	MMTM	SP,B0,B1,B2,B3,B4,B5,B6,B7,B8,B9,B10,B14
	.endif

;	.if	XUNIT=1
;	MMTM	SP,A0,A1
;	.else
;	MMTM	SP,A0,A1,a2,a3
;	.endif

	SETF	1,0,0
	CLR	A1
	MOVE	A1,@INTPEND+DIP	;CLEAR STUPID INTERRUPT PENDING
	MOVE	A1,@INTENB+DIP	;DISABLE DISPLAY INTERRUPT
*REMOVED OLD WAY OF CLEARING THOSE BITS
	SETF	16,1,0		;WORD SIGN EXTEND

	EINT			;ENABLE OTHER INTERRUPTS

	.IF NOTFINAL
	MOVE	*SP(20H+40H),A0,L
	MOVE	A0,@INTADDR,L
	.ENDIF

	.IF DEBUG
	GETPC	A1
	MOVE	*A1,A0,W
	SRL	2,A0
	SLL	2,A0
	CMPI	0F0H,A0
	JREQ	$
	.ENDIF

	move	@DPYINT,A0,W

	.if	ENABLE_DIRQ2
	cmpi	EOSINT,A0	;is this DIRQ or DIRQ2?
	jrne	DIRQ2
	.endif
	MOVE	@DIAG_DFLAG,A0,W	;SPECIAL DIRQ FOR GSP DIAGS?
	JRNZ	DIAG_DIRQ		;BR = YES

**************************************************************************
*								         *
*  	END OF SCREEN INTERRUPT. DISPLAY PROCESSING, SWITCHES, COINS	 *
* 	COLORS, ETC.							 *
*								         *
**************************************************************************
	.if	XUNIT=0
	move	@DPYCTL,a3,W		;>Shift register read to restart DMA
	movi	06810h,a0
	move	a0,@DPYCTL,W
	movi	(510*01000h),a2		;*Autoerase lines
	pixt	*a2,a2			;Mem to shift reg xfer
	move	a3,@DPYCTL,W		;Restore
	.endif

;	.if	XUNIT=1
;	MMTM	SP,A2,A3,A4,A5,A6,A7,A8,A9,A10,A11,A12,A13,A14
;	MMTM	SP,B0,B1,B2,B3,B4,B5,B6,B7,B8,B9,B10,B14
;	.else
;	MMTM	SP,A4,A5,A6,A7,A8,A9,A10,A11,A12,A13,A14
;	MMTM	SP,B0,B1,B2,B3,B4,B5,B6,B7,B8,B9,B10,B14
;	.endif

	MOVE	@GAME_STATE,A14,W
	CMPI	INDIAG,A14
	JREQ	DIRQ_CKMP2		;BR=IN DIAGNOSTICS, B13 INVALID!

*CODE TO HANDLE OVERLOAD SITUATIONS WHICH
*WILL RESULT IN A FRAME RATE REDUCTION
	MOVE	B13,B0
	CMP	B12,B0		;IS THE DMA Q EMPTY?
	JRLE	DIRQ_CKMP	;BR = Yes

*
*DMA appears to be overloaded here. Use this hook to do some stuff
*	during DEBUG mode only.
*
	.if	DEBUG
	INCM	@WAVEDMABOG,L	;Chalk this audit
	.endif

	MOVKM	1,@DMASKIPBOG,W		;Skip the bog check next time

	.if	XUNIT=1
	MOVE	@INTENB,A1,W
	BTST	B_X1E,A1
	JRZ	DIRQ_OVERLOAD		;BR = DMA not running
	.endif

	MOVI	(4096*MICRO_SECOND)/4,A1	;MAX WAIT FOR 400X256 DMA
DIRQ_DQWAIT
	CMP	B13,B0		;DMA Q CHANGE?
	JRNE	DIRQ_OVERLOAD  	;BR = YES, WE'RE OK
	DSJS	A1,DIRQ_DQWAIT

	LOCKUP			;DMA Q IS FROZEN?

	CLR	A14
	MOVE	A14,@DMAGOREG,L
	MOVE	A14,@DMAGOREG,L		;DMA off for sure

	CALLA	CLRDMAQ
	JRUC	DIRQ_OVERLOAD
DIRQ_CKMP
	MOVE	@DMASKIPBOG,A14,W	;Should we skip the DMA bog checker?
	JREQ	DIRQ_CKMP2		;BR = No
	CLR	A14
	MOVE	A14,@DMASKIPBOG,W	;We use this stuff to skip the bog
	NOT	A14			;calculator because of massive DMA
	MOVE	A14,@DMATMP,W		;overload.
DIRQ_CKMP2
	MOVE	@TIMER,A1,W	;Are the processes done?
	JRZ	DIRQ_OK		;BR = Yes
*
*CPU appears to be overloaded here.
*
	.if	DEBUG
	INCM	@WAVECPUBOG,L	;Chalk this audit
	.endif

	MOVE	@WAVEIRQS,A14,L
	BTST	0,A14
	JRZ	DIRQ_OK

**************************************************************************
* COMMENT THE FOLLOWING JUMP TO SEE THE EFFECT OF CPU BOG ON THE DISPLAY.*
;	JRUC	DIRQ_OK
**************************************************************************

*Any overload will get you here.
DIRQ_OVERLOAD
	.if	DEBUG
	MOVE	@NOVELADD,A14,W
	JRNZ	DIRQ_60HZ		;BR=WE LOCKED UP!
	.endif

	move	@SCROLLX,a0,L
	abs	a0
	cmpi	[10,0],a0
	jrls	ssc1
	CALLA	VELADD		;Always do the Velocity add
	.if	freeze_ok
	move	@game_frozen,a14,W
	jrnz	ssc1
	.endif
	move	@SCROLLX,A0,L		;ADJUST WORLD COORS FOR SCROLL
	move	@WORLDX,A1,L
	add	A0,A1
	cmpi	[585,0],a1		;we in no way will go past our edge
	jrle	dioo1
	movi	[585,0],a1
dioo1	cmpi	[-585,0],a1
	jrge	dioo2
	movi	[-585,0],a1
dioo2	move	A1,@WORLDX,L
	move	@SCROLLY,A0,L
	move	@WORLDY,A1,L
	add	A0,A1
	move	A1,@WORLDY,L
ssc1	JRUC	DIRQ_60HZ	;Skip the display processor for some headroom

*
*No overload detected here. Do things normally
*
DIRQ_OK
	CALLR	SWAP_PAGES
	callr	SRT_CLR

	MOVE	@GAME_STATE,A14,W
	CMPI	INDIAG,A14
	JRNE	D_PALTRANS			;BR=NOT IN DIAGNOSTICS
*
*UPDATE NORMAL CYCLING COLOR RAM
	MOVI	COLRTEMP+COLROFFST,A0	;GET NEW COLORS

	.if	XUNIT=1
	MOVI	CYCOLORS+(COLROFFST*2),A1	;GET ADDRESS OF CYCLE COLORS
	.else
	MOVI	CYCOLORS+COLROFFST,A1		;GET ADDRESS OF CYCLE COLORS
	.endif

	MOVK	COLRCNT,A6
COLORUP	MOVE	*A0+,a14

	.if	XUNIT=1
	move	a14,*A1+,L
	.else
	move	a14,*a1+,W
	.endif

	DSJS	A6,COLORUP
D_PALTRANS
	MOVE	@IRQSKYE,@ERASELOC,W	;MOVE IN THE CORRECT COLOR
	CALLA	PALTRANS		;XFER NEW PALETTES IF NECESSARY
	INCM	@WAVEDISPS,W	;CLICK THE WAVE DISPLAY PROC CALLS
	CALLA	DISPLAY		;GOT TO MAKE THE DONUTS

*
*Everything from here to the end of the IRQ code must
*	be executed every tick.
*
DIRQ_60HZ
	calla	speech_irq
	move	@DMATMP,a1		;Let's see where the DMA ended
	jrn	not_qued		;BR = Do not do a timing check now
	MOVE	@DMASKIPBOG,A14		;Is this an overload read?
	JRZ	DIRQ_DMA_NORM		;BR = No
	clr	a0			;Force no time left
	jruc	DIRQ_DMA_COMPUTE
DIRQ_DMA_NORM
	movi	EOSINT,A0
	sub	A1,A0
	JRN	not_qued		;BR = Something is strange with the value
DIRQ_DMA_COMPUTE
	movi	1000*10000H/EOSINT,A1
	mpyu	A0,A1
	srl	16,A1	  		;DMA time left is on a scale of
	move	a1,@DMALFT		;0 to 1000 for this frame.
	srl	3,A1
	move	@DMAAVG,A0,W
	move	A0,A2
	srl	3,A2
	sub	A2,A0
	add	A0,A1
	move	A1,@DMAAVG,W		;Average value to make it useful

not_qued
	CLR	A14
	NOT	A14
	move	a14,@DMATMP
	MOVE	@TIMER,A1		;HIT PROCESS TIMER
	INC	A1
	MOVE	A1,@TIMER
	.IF DEBUG
	.ELSE
	CMPI	200,A1
	JRLO	NO_IRQDOG		;NOTHING IS HUNG
	DINT
	JRUC	$			;HANG AND LET THE DOG BITE.
NO_IRQDOG
	.ENDIF
	CALLA	COININT		;HANDLE SOME COINS!
	CALLR	SWSCAN		;SCAN SWITCHES TO TRIGGER PROCS.

	.if	freeze_ok
	move	@game_frozen,a14,W
	jrz	noskp
	inc	a14
	move	a14,@game_frozen,W
	jruc	IRQ_SKIP_WI
	.endif

noskp	INCM	@WAVEIRQS,L	;CLICK THE WAVE DIRQ COUNT
IRQ_SKIP_WI
	DINT
	SETF	1,0,0
	MOVK	1,A0
	MOVE	A0,@INTENB+DIP	;ENABLE DISPLAY INTERRUPT
	SETF	16,1,0
	MOVE	@IRQLED,A0,W
	INC	A0
	MOVE	A0,@IRQLED,W
	CMPI	8,A0
	JRLT	DIRQX
*
*DO EVERYTHING FROM HERE TO DIRQX EVERY 8 TICKS
*
	CLR	A0
	MOVE	A0,@IRQLED,W

	.if	XUNIT=1
	MOVE	@SYSCOPY,A0
	XORI	LED_ON<<8,A0
	MOVE	A0,@SYSCOPY	; XUNIT
	srl	8,a0	 	; XUNIT
	MOVE	A0,@SYSCTRL1,L	; XUNIT
	.else
	MOVE	@SYSCTRL,A0,W
	xori	LED_ON,a0
;	move	a0,@SYSCOPY
	move	a0,@SYSCTRL,W
	.endif

	MOVE	a0,@WDOG_BONE 	; XUNIT THROW ROVER A BONE
DIRQX	.IF NOTFINAL
	move	@INTADDR,@LASTINT,L
	clr	A0
	move	A0,@INTADDR,L
	.ENDIF

	.if	ENABLE_DIRQ2
*
*CHECK IF AUTO-ERASE COLORS HAVE CHANGED, IF SO
*CREATE A NEW INTERRUPT TO STORE DATA
*
	move	@NewAECol,A0,L
	move	@OldAECol,A1,L
	cmp	A0,A1
	jrz	SkAEInt

SetAEInt
	movi	DIRQ2INT,A0	;STUFF DPYINT FOR DIRQ2 (CHANGE AUTOERASE COL)
	move	A0,@DPYINT,W
	.endif
SkAEInt
	MMFM	SP,B0,B1,B2,B3,B4,B5,B6,B7,B8,B9,B10,B14
	MMFM	SP,A0,A1,A2,A3,A4,A5,A6,A7,A8,A9,A10,A11,A12,A13,A14

	RETI

**************************************************************************
*								         *
* SPECIAL DISPLAY INTERRUPT FOR DIAGNOSTIC TEST THAT DO ALL DRAWING	 *
* WITH THE DMA(i.e. SWITCH TEST, DIPSWITCH TEST, etc.)			 *
* FEEDS WATCHDOG AND INCS TIMER						 *
*								         *
**************************************************************************
DIAG_DIRQ
	MOVE	A0,@WDOG_BONE	; XUNIT THROW ROVER A BONE
	MOVE	@TIMER,A0	;HIT PROCESS TIMER
	INC	A0
	MOVE	A0,@TIMER
	DINT
	SETF	1,0,0
	MOVK	1,A0
	MOVE	A0,@INTENB+DIP	;ENABLE DISPLAY INTERRUPT
;	.if	XUNIT=1
;	mmfm	SP,A0,A1
;	.else
;	mmfm	SP,A0,A1,a2,a3
;	.endif

	MMFM	SP,B0,B1,B2,B3,B4,B5,B6,B7,B8,B9,B10,B14
	MMFM	SP,A0,A1,A2,A3,A4,A5,A6,A7,A8,A9,A10,A11,A12,A13,A14

	RETI

**************************************************************************
*								         *
* DIRQ2 - USED TO CHANGE THE COLOR OF THE AUTO-ERASE LINES. IF THE DMA	 *
* 	IS NOT CURRENTLY BUSY. IF IT IS, WE'LL TRY NEXT SCREEN.		 *
*								         *
**************************************************************************
DIRQ2	movi	EOSINT,A0	;STUFF DPYINT FOR NEXT INTERRUPT
	move	A0,@DPYINT,W
	cmp	B12,B13		;Is Q Non-Empty?
	jrgt	DIRQ2X
	MOVE	@DMAGOREG,A0,L	; XUNIT DMA BUSY?
	JRN	DIRQ2X

	;*** SET UP DMA TRANSFER TO RESTUFF AUTOERASE COLOR ***
	move	@NewAECol,A1,W
	move	@OldAECol,A0,W
	cmp	A0,A1
	jreq	SkSetAE
	move	A1,@OldAECol,W
	;*** STUFF CORRECT COLOR IN AUTOERASE LINES ***
	movi	DMAREGS,A1
	MOVI	01FF01FEH,A0
	MOVE	A0,*A1,L	;WINDOW BOTTOM - TOP
	MOVI	01000100H,A0
	MOVE	A0,-*A1,L	;Y-SCALE:X-SCALE
	move	@OldAECol,A0
	sll	16,a0
	MOVE	A0,-*A1,L	;CONST:PALETTE
	movi	[2,SCRWIDTH],A0
	MOVE	A0,-*A1,L	;VSIZE:HSIZE
	movi	[510,CENTER_XSHIFT],A0

	move	A0,-*A1,L	;DESTINATION Y:X
	movi	IROM,A0		; XUNIT
	MOVE	A0,-*A1,L	;IMAGE SAG
	movi	DMACAL<<16,A0
	MOVE	A0,-*A1,L		;STUFF THE CONTROL:OFFSET
SkSetAE

DIRQ2X
	DINT
	SETF	1,0,0
	MOVK	1,A0
	MOVE	A0,@INTENB+DIP	;ENABLE DISPLAY INTERRUPT
;	.if	XUNIT=1
;	mmfm	SP,A0,A1
;	.else
;	mmfm	SP,A0,A1,a2,a3
;	.endif

	MMFM	SP,B0,B1,B2,B3,B4,B5,B6,B7,B8,B9,B10,B14
	MMFM	SP,A0,A1,A2,A3,A4,A5,A6,A7,A8,A9,A10,A11,A12,A13,A14

	RETI
*
*SWITCHES SCANNED HERE WILL ACTIVATE THE PROCESSES IN THE SWITCH PROCESS
*TABLE.
*BASHES A0,A1,A2 & A3 SO BEWARE!
SWSCAN

	move	@SWITCH,a0	; XUNIT ST
	move	@SWITCH2,a14
	sll	16,a14
	movy	a14,a0		; XUNIT END
	MOVE	@SWTEMP1,A1,L	;PREVIOUS STATE T=N-1
	MOVE	@SWTEMP2,A2,L	;PREVIOUS PREVIOUS T=N-2
	MOVE	A1,@SWTEMP2,L	;NEW PREVIOUS PREVIOUS
	MOVE	A0,@SWTEMP1,L	;NEW PREVIOUS

	.if	freeze_ok
	move	@game_frozen,a14,W
	jrnz	skip_sw1

	.endif

;	MOVE	@SWLOGIC,A14,L	;GET PREVIOUS LOGICAL STATE
;	ANDN	A0,A14		;UPDATE SWITCH STATES

	AND	A1,A2
	ANDN	A0,A2		;LOOK FOR 110
	JREQ	SWITCH2_CHECK	;NO SWITCHES

;	OR	A2,A14		;ADD NEW SWITCH STATES

	MOVE	@SWSTACK,A3,L	;SWITCH ACTIVATION STACK
SWSCLP				;FIND BIT SET
	CMPI	SWSTMN,A3	;SWITCH STACK OVERFLOW?
	JREQ	SWSCX1		;YEP, QUIT
	LMO	A2,A0		;1'S COMP LEFTMOST BIT
	RL	A0,A2		;GET RID OF BIT
	SLL	1,A2
	MOVK	31,A1		;CALC TRUE BIT #
	SUB	A0,A1
	MOVE	A1,-*A3		;PUSH SWITCH NUMBER ON STACK (0-15)
	RL	A1,A2		;RESTORE SWITCH WORD WITHOUT BIT
	JRNE	SWSCLP
SWSCX1
	MOVE	A3,@SWSTACK,L	;RESTORE SWITCH STACK
*
SWITCH2_CHECK

;	MOVE	A14,@SWLOGIC,L	;SAVE CURRENT LOGICAL STATE

skip_sw1
	move	@COINS,a0
	move	@DIPSWITCH,a14
	sll	16,a14
	movy	a14,a0		; XUNIT END
	MOVE	@SW2TEMP1,A1,L	;PREVIOUS STATE T=N-1
	MOVE	@SW2TEMP2,A2,L	;PREVIOUS PREVIOUS T=N-2
	MOVE	A1,@SW2TEMP2,L	;NEW PREVIOUS PREVIOUS
	MOVE	A0,@SW2TEMP1,L	;NEW PREVIOUS
	AND	A1,A2
	ANDN	A0,A2		;LOOK FOR 110
	JREQ	SWSCX		;NO SWITCHES
	MOVE	@SWSTACK,A3,L	;SWITCH ACTIVATION STACK
SW2SCLP				;FIND BIT SET
	CMPI	SWSTMN,A3	;SWITCH STACK OVERFLOW?
	JREQ	SW2SCX1		;YEP, QUIT
	LMO	A2,A0		;1'S COMP LEFTMOST BIT
	RL	A0,A2		;GET RID OF BIT
	SLL	1,A2
	MOVI	63,A1
	SUB	A0,A1
	MOVE	A1,-*A3		;PUSH SWITCH NUMBER ON STACK (0-15)
	RL	A1,A2		;RESTORE SWITCH WORD WITHOUT BIT
	JRNE	SW2SCLP
SW2SCX1
	MOVE	A3,@SWSTACK,L	;RESTORE SWITCH STACK
SWSCX
	RETS

**************************************************************************
*                                                                        *
* INITIO - INITIALIZE THE GSP I/O REGISTERS				 *
*                                                                        *
**************************************************************************
INITIO
	MMTM	SP,B0,B2,B7
	MOVI	INITDATA,B0
	MOVI	IDATALEN,B7

	.if XUNIT=1
	MOVI	VESYNC,B2
	BLMOVE	1,1				;TRANSFER I/O REGS
	movi	DPYSTRT0,a14	; XUNIT
	move	a14,@DPYST,L	; XUNIT
	.else
	movi	HESYNC,b2
	srl	5,b7
_ior_move
	move	*b0+,*b2+,L
	dsjs	b7,_ior_move
;	movi	0fffch,a14
	movi	0ch,a14
	move	a14,@DPYSTRT,W
	.endif

	MMFM	SP,B0,B2,B7
	RETS

*
*DUMMY FOR THE SWITCHES
DUMDIE	JAUC	SUCIDE		;NOTHING PROCESS

**************************************************************************
*                                                                        *
* BADTRAP - COME HERE WHEN A TRAP IS HIT THAT IS NOT DEFINED AND LOG IT. *
*                                                                        *
**************************************************************************
BADTRAP
	MOVI	1,A14
	move	*SP(20h),B14,L	;Send the return address, we know its bad
	CALLA	DUMP_IT
	AUDIT	AUD_BADTRAP	;CLICK A SOFTWARE TRAP
	DINT
	JRUC	$	;LET THE WATCH DOG CATCH US

**************************************************************************
*								         *
* 	Switch process activation table					 *
* 	Used in conjunction with the IRQ switch scanner.		 *
* 									 *
* 	     .WORD  PROCESS ID						 *
* 	     .LONG  STARTING ADDR					 *
*								         *
**************************************************************************
SWTAB
*
*Players 1 and 2 start here, read at location SWITCH
*
	WL	0,0			;SW  0 -- (JAMMA P1 Up)
	WL	0,0			;SW  1 -- (JAMMA P1 Down)
	WL	0,0			;SW  2 -- (JAMMA P1 Left)
	WL	0,0			;SW  3 -- (JAMMA P1 Right)
	WL	PID_IND,SW_4		;SW  4 -- (JAMMA P1 A)
	WL	PID_IND,SW_5		;SW  5 -- (JAMMA P1 B)
	WL	PID_IND,SW_6		;SW  6 -- (JAMMA P1 C)
    	WL	PID_IND,SW_7		;SW  7 -- (JAMMA P1 D)
  	WL	0,0			;SW  8 -- (JAMMA P2 Up)
	WL	0,0			;SW  9 -- (JAMMA P2 Down)
	WL	0,0			;SW 10 -- (JAMMA P2 Left)
	WL	0,0			;SW 11 -- (JAMMA P2 Right)
	WL	PID_IND,SW_12		;SW 12 -- (JAMMA P2 A)
	WL	PID_IND,SW_13		;SW 13 -- (JAMMA P2 B)
    	WL	PID_IND,SW_14		;SW 14 -- (JAMMA P2 C)
    	WL	PID_IND,SW_15		;SW 15 -- (JAMMA P2 D)
*
*Players 3 and 4 start here, read at location SWITCH2
*
	WL	0,0			;SW 16 -- (JAMMA P3 Up)
	WL	0,0			;SW 17 -- (JAMMA P3 Down)
	WL	0,0			;SW 18 -- (JAMMA P3 Left)
	WL	0,0			;SW 19 -- (JAMMA P3 Right)
	WL	PID_IND,SW_20		;SW 20 -- (JAMMA P3 A)
	WL	PID_IND,SW_21		;SW 21 -- (JAMMA P3 B)
    	WL	PID_IND,SW_22		;SW 22 -- (JAMMA P3 C)
    	WL	PID_IND,SW_23		;SW 23 -- (JAMMA P3 D)
    	WL	0,0			;SW 24 -- (JAMMA P4 Up)
    	WL	0,0			;SW 25 -- (JAMMA P4 Down)
    	WL	0,0			;SW 26 -- (JAMMA P4 Left)
    	WL	0,0			;SW 27 -- (JAMMA P4 Right)
    	WL	PID_IND,SW_28		;SW 28 -- (JAMMA P4 A)
    	WL	PID_IND,SW_29		;SW 29 -- (JAMMA P4 B)
    	WL	PID_IND,SW_30		;SW 30 -- (JAMMA P4 C)
    	WL	PID_IND,SW_31		;SW 31 -- (JAMMA P4 D)
*
*Coins and misc start here, read at location COINS
*
    	WL	PID_LC,LCOIN		;SW 32 -- Left Coin
    	WL	PID_RC,RCOIN		;SW 33 -- Right Coin
	WL	PID_IND,SW_34		;SW 34 -- Player 1 Start
    	WL	PID_SLAM,SLAM		;SW 35 -- SLAM!

    	WL	PID_DIAG,DIAG		;SW 36 -- Diagnostics
	WL	PID_IND,SW_37		;SW 37 -- Player 2 Start
    	WL	PID_LC,SCOIN		;SW 38 -- Service Credit
    	WL	PID_CC,CCOIN		;SW 39 -- Center Coin

	WL	PID_XC,XCOIN		;SW 40 -- Fourth Coin
	WL	PID_IND,SW_41		;SW 41 -- Player 3 Start
    	WL	PID_IND,SW_42		;SW 42 -- Player 4 Start
	WL	PID_VOLUME,SWITCH_VOLUME_DOWN ;SW 43 -- Volume Down

	WL	PID_VOLUME,SWITCH_VOLUME_UP   ;SW 44 -- Volume Up
	WL	0,0			;SW 45 -- COIN DOOR INTERLOCK
    	WL	PID_INDW,FREEZE_ABSOLUTE ;SW 46 -- Freeze Switch
	WL	PID_XC,DBVCOIN		;SW 47 -- Bill acceptor
*
*DIP switches start here, read at location DIPSWITCH
*
    	WL	0,0			;SW 48 -- SWITCH 48	UJ2-8
    	WL	0,0			;SW 49 -- SWITCH 49	UJ2-7
    	WL	0,0			;SW 50 -- SWITCH 50	UJ2-6
    	WL	0,0			;SW 51 -- SWITCH 51	UJ2-5
    	WL	0,0			;SW 52 -- SWITCH 52	UJ2-4
    	WL	0,0			;SW 53 -- SWITCH 53	UJ2-3
    	WL	0,0			;SW 54 -- SWITCH 54	UJ2-2
    	WL	0,0			;SW 55 -- SWITCH 55	UJ2-1
    	WL	0,0			;SW 56 -- SWITCH 56	UJ1-8
    	WL	0,0			;SW 57 -- SWITCH 57	UJ1-7
    	WL	0,0			;SW 58 -- SWITCH 58	UJ1-6
    	WL	0,0			;SW 59 -- SWITCH 59	UJ1-5
    	WL	0,0			;SW 60 -- SWITCH 60	UJ1-4
    	WL	0,0			;SW 61 -- SWITCH 61	UJ1-3
    	WL	PID_INDW,FREEZE_ABSOLUTE ;SW 62 -- VIDEO FREEZE	UJ1-2
    	WL	PID_DIAG,DIAG		;SW 63 -- TEST SWITCH	UJ1-1

* VIDEO CONTROL REGISTERS INITIAL VALUES
	.if XUNIT=1
	.sect	"COLDSTRT"

INITDATA
	.WORD   0003H*2			;0C0000000H -- vesync
	.WORD	0002BH			;0C0000010H -- hesync
	.WORD   ENDVBLNK		;0C0000020H -- VEBLNK
	.WORD	00065H			;0C0000030H -- heblnk
	.WORD   0100H+(ENDVBLNK-2)	;0C0000040H -- VSBLNK
	.WORD	001f5H			;0C0000050H -- hsblnk
	.WORD   0120H			;0C0000060H -- vtotal
	.WORD	001f9H			;0C0000070H -- htotal

	.WORD   0D007H			;0C0000080H -- DPYCTL
	.WORD	0			;0C0000090H -- dpystrt
	.WORD	EOSINT			;0C00000A0H -- dpyint * INITIALLY HALF SCREEN
	.WORD	INI_CTRL		;0C00000B0H -- control
	.WORD	04h  			;0C00000C0H -- hstdata
	.WORD	00h			;0C00000D0H -- hstadrl
	.WORD	00h			;0C00000E0H -- hstadrh
	.WORD	00h			;0C00000F0H -- hstctll
	.WORD	00h			;0C0000100H -- hstctlh
	.WORD	00h			;0C0000110H -- intenbl
	.WORD	00h			;0C0000120H -- intpend
	.WORD	00h			;0C0000130H -- convsp
	.WORD	CONV_PTCH		;0C0000140H -- convdp
	.WORD	PXSIZE			;0C0000150H -- psize
	.WORD	00h			;0C0000160H -- pmaskl
	.WORD	00h			;0C0000170H -- pmaskh
	.WORD	00h			;0C0000180H -- CONVMP
	.WORD	INI_CTRL		;0C0000190H -- CONTROL
	.WORD	01108h			;0C00001A0H -- CONFIG

	.WORD	00h			;0C00001B0H -- DPYTAP
	.WORD	04h			;0C00001C0H -- VCOUNT
	.WORD	00h			;0C00001D0H -- HCOUNT
	.WORD	00h			;0C00001E0H -- DPYADR
	.WORD	00h			;0C00001F0H -- REFADR

	.WORD	00h			;0C0000200H -- REG200
	.WORD	00h			;0C0000210H -- REG210
	.WORD	00h			;0C0000220H -- REG220
	.WORD	00h			;0C0000230H -- REG230
	.WORD	1000h			;0C0000240H -- DINC
	.WORD	00h			;0C0000250H -- REG250
	.WORD	00h			;0C0000260H -- REG260

	.WORD	01D5h			;0C0000270H -- HESERR

	.else

INITDATA
	.word	02bh		;0C0000000H -- HESYNC
	.word	065h	;HEBLNKINIT	;0C0000010H -- HEBLNK
	.word	01f5h		;0C0000020H -- HSBLNK
	.word	01f9h		;0C0000030H -- HTOTAL
	.word	3		;0C0000040H -- VESYNC
	.word	20		;0C0000050H -- VEBLNK
	.word	274		;0C0000060H -- VSBLNK	;254 lines
	.word	288		;0C0000070H -- VTOTAL
	.word	0f010h		;0C0000080H -- DPYCTL	ENV|NIL|DXV|SRE|010H
	.word	0fffch	;000c	;0C0000090H -- DPYSTRT
;	.word	0FFF0H		;0C0000090H -- DPYSTRT
	.word	EOSINT		;0C00000A0H -- DPYINT
	.word	2ch		;0C00000B0H -- CONTROL
	.word	0		;0C00000C0H -- HSTDATA
	.word	0		;0C00000D0H -- HSTADRL
	.word	0		;0C00000E0H -- HSTADRH
	.word	0		;0C00000F0H -- HSTCTLL
	.word	0		;0C0000100H -- HSTCTLH
	.word	0		;0C0000110H -- INTENBL
	.word	0		;0C0000120H -- INTPEND
	.word	0		;0C0000130H -- CONVSP
	.word	0		;0C0000140H -- CONVDP
	.word	PXSIZE		;0C0000150H -- PSIZE
	.word	0		;0C0000160H -- PMASK
	.word	0		;0C0000170H -- RESERVED
	.word	0		;0C0000180H -- RESERVED
	.word	0		;0C0000190H -- RESERVED
	.word	0		;0C00001A0H -- RESERVED
	.word	28		;0C00001B0H -- DPYTAP

	.endif


IDATALEN	EQU	$-INITDATA	;Bit length of I/O init table

*
*INITIALIZE ALL 32 TRAP VECTORS
*
	.SECT	"VECTORS"

	.if	XUNIT=1
;	.LONG	BADTRAP		;TRAP 31
;	.LONG	BADTRAP		;TRAP 30	ILLOP --- Illegal Opcode
;	.LONG	BADTRAP		;TRAP 29
;	.LONG	BADTRAP		;TRAP 28
;	.LONG	BADTRAP		;TRAP 27
;	.LONG	BADTRAP		;TRAP 26
;	.LONG	BADTRAP		;TRAP 25
;	.LONG	BADTRAP		;TRAP 24
;	.LONG	BADTRAP		;TRAP 23
;	.LONG	BADTRAP		;TRAP 22
;	.LONG	BADTRAP		;TRAP 21
;	.LONG	BADTRAP		;TRAP 20
;	.LONG	BADTRAP		;TRAP 19
;	.LONG	BADTRAP		;TRAP 18
;	.LONG	BADTRAP		;TRAP 17
;	.LONG	BADTRAP		;TRAP 16
	.else
	.LONG	BADTRAP		;TRAP 31
	.LONG	BADTRAP		;TRAP 30	ILLOP --- Illegal Opcode
	.LONG	BADTRAP		;TRAP 29
	.LONG	BADTRAP		;TRAP 28
	.LONG	BADTRAP		;TRAP 27
	.LONG	BADTRAP		;TRAP 26
	.LONG	BADTRAP		;TRAP 25
	.LONG	BADTRAP		;TRAP 24
	.LONG	BADTRAP		;TRAP 23
	.LONG	BADTRAP		;TRAP 22
	.LONG	BADTRAP		;TRAP 21
	.LONG	BADTRAP		;TRAP 20
	.LONG	BADTRAP		;TRAP 19
	.LONG	BADTRAP		;TRAP 18
	.LONG	BADTRAP		;TRAP 17
	.LONG	BADTRAP		;TRAP 16
	.endif

	.LONG	BADTRAP		;TRAP 15
	.LONG	BADTRAP		;TRAP 14
	.LONG	BADTRAP		;TRAP 13
	.LONG	BADTRAP		;TRAP 12
	.LONG	BADTRAP		;TRAP 11	WV --- Window Violation
	.LONG	DIRQ		;TRAP 10	DI --- Display Interrupt
	.LONG	BADTRAP		;TRAP 9		HI --- Host Interrupt
	.LONG	BADTRAP		;TRAP 8		NMI -- NonMaskable Interrupt
	.LONG	BADTRAP		;TRAP 7
	.LONG	BADTRAP		;TRAP 6
	.LONG	BADTRAP		;TRAP 5
	.LONG	BADTRAP		;TRAP 4
	.LONG	BADTRAP		;TRAP 3
	.LONG	LINT2_SERVICE	;TRAP 2		INT2 --- External Interrupt 2
	.LONG	DMAINT		;TRAP 1		INT1 --- External Interrupt 1
	.LONG	POWERUP		;TRAP 0		Reset

	.end
